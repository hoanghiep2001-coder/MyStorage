{"version":3,"sources":["file:///D:/PA_2024/3D/BilliardPuzzle/Billiard/assets/Ops/Op13/Scripts/GamePlay/RaycastShootPoint.ts"],"names":["_decorator","Component","geometry","misc","Node","PhysicsSystem","Vec3","Global","ccclass","property","RaycastShootPoint","ZERO","start","update","deltaTime","endGame","RaycastLeft","Raycast","RaycastRight","CalculateLine","outRay","Ray","fromPoints","originRayLeft","getWorldPosition","targetRayLeft","mask","maxDistance","queryTrigger","instance","raycastClosest","raycastClosestResult","distanceLeft","distance","collider","node","layer","targetLeft","out","active","in","hitPointLeft","hitPoint","clone","originRayRight","targetRayRight","distanceRight","targetRight","hitPointRight","originRay","targetRay","distanceCenter","targetCenter","hitPointCenter","GetTarget","target","x","line","setWorldScale","startPoint","endPoint","angleOut","calculateAngleBetweenPoints","offsetIn","z","angleIn","setRotationFromEuler","setScale","Math","abs","circle","setPosition","getWorldScale","pointA","pointB","deltaX","parseFloat","toFixed","deltaZ","angleRad","atan2","angleDeg","radiansToDegrees"],"mappings":"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","sourcesContent":["\nimport { _decorator, Color, Component, geometry, gfx, Graphics, LineComponent, log, Material, math, misc, ModelComponent, Node, PhysicsSystem, Vec3 } from 'cc';\nimport Global from '../Utility3D/Global';\nconst { ccclass, property } = _decorator;\n\n/**\n * Predefined variables\n * Name = RaycastShootPoint\n * DateTime = Thu May 23 2024 08:34:54 GMT+0700 (Indochina Time)\n * Author = PhongDNRocket123\n * FileBasename = RaycastShootPoint.ts\n * FileBasenameNoExtension = RaycastShootPoint\n * URL = db://assets/Scripts/GamePlay/RaycastShootPoint.ts\n * ManualUrl = https://docs.cocos.com/creator/3.4/manual/en/\n *\n */\n\n@ccclass('RaycastShootPoint')\nexport class RaycastShootPoint extends Component {\n    @property(Node)\n    line: Node = null;\n\n    @property(Node)\n    circle: Node = null;\n\n    @property(Node)\n    out: Node = null;\n\n    @property(Node)\n    in: Node = null;\n\n    @property(Node)\n    originRay: Node = null;\n\n    @property(Node)\n    targetRay: Node = null;\n\n    @property(Node)\n    originRayLeft: Node = null;\n\n    @property(Node)\n    targetRayLeft: Node = null;\n\n    @property(Node)\n    originRayRight: Node = null;\n\n    @property(Node)\n    targetRayRight: Node = null;\n\n\n    distance: number = 0;\n    target: Node = null;\n    hitPoint: Vec3 = Vec3.ZERO;\n\n    targetCenter: Node = null;\n    targetLeft: Node = null;\n    targetRight: Node = null;\n\n\n    hitPointCenter: Vec3 = Vec3.ZERO;\n    hitPointLeft: Vec3 = Vec3.ZERO;\n    hitPointRight: Vec3 = Vec3.ZERO;\n\n    distanceCenter: number = 0;\n    distanceLeft: number = 0;\n    distanceRight: number = 0;\n\n\n    protected start(): void {\n    }\n\n    update(deltaTime: number) {\n        if(Global.endGame) return;\n\n        //  log(this.originRayLeft.getWorldPosition());\n        this.RaycastLeft();\n        this.Raycast();\n        this.RaycastRight();\n        this.CalculateLine();\n    }\n    RaycastLeft() {\n        const outRay = new geometry.Ray();\n        geometry.Ray.fromPoints(outRay, this.originRayLeft.getWorldPosition(), this.targetRayLeft.getWorldPosition());\n\n        const mask = (1 << 1) + (1 << 2) + (1 << 3);\n        // const mask = 0xffffffff;\n        const maxDistance = 10000000;\n        const queryTrigger = false;\n\n        if (PhysicsSystem.instance.raycastClosest(outRay, mask, maxDistance, queryTrigger)) {\n            const raycastClosestResult = PhysicsSystem.instance.raycastClosestResult;\n            this.distanceLeft = raycastClosestResult.distance;\n\n            // log(raycastClosestResult.collider.node.name + \" \" + raycastClosestResult.hitPoint);\n            //log(\"left \" + this.distanceLeft);\n\n            // log(raycastClosestResult.hitNormal);\n            //  log(this.distance);\n            // this.line.setWorldScale(0.48 * this.distance / 0.512, 0.02, 1);\n            //ball\n            if (raycastClosestResult.collider.node.layer == 2) {\n                this.targetLeft = raycastClosestResult.collider.node;\n                // log(this.targetLeft.name);\n                this.out.active = false;\n                this.in.active = false;\n            }\n            //wall            \n            else {\n                this.targetLeft = null;\n                this.out.active = false;\n                this.in.active = false;\n            }\n            this.hitPointLeft = raycastClosestResult.hitPoint.clone();\n            //  log(\"left \" + this.hitPointLeft);\n\n            //   log(this.hitPointLeft);\n            // // calcultate  angle\n            // if (this.target) {\n            //     this.in.setWorldPosition(this.target.getWorldPosition());\n            //     // log(this.target.name);\n\n            //     const startPoint = raycastClosestResult.hitPoint.x <= this.target.getWorldPosition().x ? raycastClosestResult.hitPoint : this.target.getWorldPosition();\n            //     const endPoint = raycastClosestResult.hitPoint.x >= this.target.getWorldPosition().x ? raycastClosestResult.hitPoint : this.target.getWorldPosition();\n            //     const angleOut = this.calculateAngleBetweenPoints(startPoint, endPoint);\n\n            //     //log(angleOut)\n            //     const offsetIn = startPoint.z >= endPoint.z ? 1 : 0;\n\n            //     const angleIn = angleOut + 90 + offsetIn * 180;\n            //     this.out.setRotationFromEuler(new Vec3(0, 0, angleOut));\n            //     this.in.setRotationFromEuler(new Vec3(0, 0, angleIn));\n\n            //     this.in.setScale(((Math.abs(angleOut)) / 90) * 2, 0.35, 1);\n            //     this.target = null;\n            // }\n\n            // //set postion circle\n            // let hitPoint = raycastClosestResult.hitPoint.clone();\n            // const point = hitPoint;\n\n            // this.circle.setPosition(0.503 * this.line.getWorldScale().x / 0.48, 0, 0);\n\n        }\n    }\n\n    RaycastRight() {\n        const outRay = new geometry.Ray();\n        geometry.Ray.fromPoints(outRay, this.originRayRight.getWorldPosition(), this.targetRayRight.getWorldPosition());\n\n        const mask = (1 << 1) + (1 << 2) + (1 << 3);\n        // const mask = 0xffffffff;\n        const maxDistance = 10000000;\n        const queryTrigger = false;\n\n        if (PhysicsSystem.instance.raycastClosest(outRay, mask, maxDistance, queryTrigger)) {\n            const raycastClosestResult = PhysicsSystem.instance.raycastClosestResult;\n            this.distanceRight = raycastClosestResult.distance;\n            //   log(\"right \" + this.distanceRight);\n            //  log(Vec3.distance(this.originRayRight.getWorldPosition(), raycastClosestResult.hitPoint.clone()));\n            // log(raycastCVthis.distance);\n            //  this.line.setWorldScale(0.48 * this.distance / 0.512, 0.02, 1);\n            //ball\n            if (raycastClosestResult.collider.node.layer == 2) {\n                this.targetRight = raycastClosestResult.collider.node;\n                this.out.active = false;\n                this.in.active = false;\n            }\n            //wall            \n            else {\n                this.targetRight = null;\n                this.out.active = false;\n                this.in.active = false;\n            }\n            this.hitPointRight = raycastClosestResult.hitPoint.clone();\n            //    log(\"right \" + this.hitPointRight);\n\n            // // calcultate  angle\n            // if (this.target) {\n            //     this.in.setWorldPosition(this.target.getWorldPosition());\n            //     // log(this.target.name);\n\n            //     const startPoint = raycastClosestResult.hitPoint.x <= this.target.getWorldPosition().x ? raycastClosestResult.hitPoint : this.target.getWorldPosition();\n            //     const endPoint = raycastClosestResult.hitPoint.x >= this.target.getWorldPosition().x ? raycastClosestResult.hitPoint : this.target.getWorldPosition();\n            //     const angleOut = this.calculateAngleBetweenPoints(startPoint, endPoint);\n\n            //     //log(angleOut)\n            //     const offsetIn = startPoint.z >= endPoint.z ? 1 : 0;\n\n            //     const angleIn = angleOut + 90 + offsetIn * 180;\n            //     this.out.setRotationFromEuler(new Vec3(0, 0, angleOut));\n            //     this.in.setRotationFromEuler(new Vec3(0, 0, angleIn));\n\n            //     this.in.setScale(((Math.abs(angleOut)) / 90) * 2, 0.35, 1);\n            //     this.target = null;\n            // }\n\n            // //set postion circle\n            // let hitPoint = raycastClosestResult.hitPoint.clone();\n            // const point = hitPoint;\n\n            // this.circle.setPosition(0.503 * this.line.getWorldScale().x / 0.48, 0, 0);\n\n        }\n    }\n    Raycast() {\n        const outRay = new geometry.Ray();\n        geometry.Ray.fromPoints(outRay, this.originRay.getWorldPosition(), this.targetRay.getWorldPosition());\n\n        const mask = (1 << 1) + (1 << 2) + (1 << 3);\n        // const mask = 0xffffffff;\n        const maxDistance = 10000000;\n        const queryTrigger = false;\n\n        if (PhysicsSystem.instance.raycastClosest(outRay, mask, maxDistance, queryTrigger)) {\n            const raycastClosestResult = PhysicsSystem.instance.raycastClosestResult;\n            this.distanceCenter = raycastClosestResult.distance;\n            // log(raycastClosestResult.hitNormal);\n            //  log(\"center \" + this.distanceCenter);\n            //  this.line.setWorldScale(0.48 * this.distance / 0.512, 0.02, 1);\n            //ball\n            if (raycastClosestResult.collider.node.layer == 2) {\n                this.targetCenter = raycastClosestResult.collider.node;\n                this.out.active = false;\n                this.in.active = false;\n            }\n            //wall            \n            else {\n                this.targetCenter = null;\n                this.out.active = false;\n                this.in.active = false;\n            }\n            this.hitPointCenter = raycastClosestResult.hitPoint.clone();\n            //   log(\"center \" + this.hitPointCenter);\n            // // calcultate  angle\n            // if (this.target) {\n            //     this.in.setWorldPosition(this.target.getWorldPosition());\n            //     // log(this.target.name);\n\n            //     const startPoint = raycastClosestResult.hitPoint.x <= this.target.getWorldPosition().x ? raycastClosestResult.hitPoint : this.target.getWorldPosition();\n            //     const endPoint = raycastClosestResult.hitPoint.x >= this.target.getWorldPosition().x ? raycastClosestResult.hitPoint : this.target.getWorldPosition();\n            //     const angleOut = this.calculateAngleBetweenPoints(startPoint, endPoint);\n\n            //     //log(angleOut)\n            //     const offsetIn = startPoint.z >= endPoint.z ? 1 : 0;\n\n            //     const angleIn = angleOut + 90 + offsetIn * 180;\n            //     this.out.setRotationFromEuler(new Vec3(0, 0, angleOut));\n            //     this.in.setRotationFromEuler(new Vec3(0, 0, angleIn));\n\n            //     this.in.setScale(((Math.abs(angleOut)) / 90) * 2, 0.35, 1);\n            //     this.targetCenter = null;\n            // }\n\n            // //set postion circle\n            // let hitPoint = raycastClosestResult.hitPoint.clone();\n            // const point = hitPoint;\n\n            // this.circle.setPosition(0.503 * this.line.getWorldScale().x / 0.48, 0, 0);\n\n        }\n    }\n\n    GetTarget() {\n        if (this.targetCenter == null && this.targetLeft == null && this.targetRight == null) {\n            //  log(\"all null\");\n            this.target = null;\n            this.distance = this.distanceCenter;\n            this.hitPoint = this.hitPointCenter;\n        } else {\n\n            // target left null\n            if (this.targetLeft == null) {\n\n                //target left null + target center null\n                if (this.targetCenter == null) {\n                    //target left null + target center null + target right null\n\n                    if (this.targetRight == null) {\n                        //     log(\"target left null + target center null + target right null\");\n\n                        this.target = this.targetCenter;\n                        this.distance = this.distanceCenter;\n                        this.hitPoint = this.hitPointCenter;\n\n                        //target left null + target center null + target right !=null\n\n                    } else {\n                        //    log(\"target left null + target center null + target right !=null\");\n\n                        this.target = this.targetRight;\n                        this.distance = this.distanceRight\n                        this.hitPoint = this.hitPointRight;\n                    }\n\n                }\n                //target left null +target center != null \n\n                else {\n                    //target left null + target center !=null + target right null\n\n                    if (this.targetRight == null) {\n                        //    log(\"target left null + target center !=null + target right null\");\n\n                        this.target = this.targetCenter;\n                        this.distance = this.distanceCenter;\n                        this.hitPoint = this.hitPointCenter;\n                    }\n                    //target left null + target center !=null + target right !=null\n\n                    else {\n                        //     log(\"target left null + target center !=null + target right !=null\");\n\n\n                        if (this.hitPointCenter.x <= this.hitPointRight.x) {\n                            this.target = this.targetCenter;\n                            this.distance = this.distanceCenter;\n                            this.hitPoint = this.hitPointCenter;\n                        } else {\n                            this.target = this.targetRight;\n                            this.distance = this.distanceRight;\n                            this.hitPoint = this.hitPointRight;\n                        }\n                    }\n                }\n            }\n            // target left != null\n\n            else {\n\n                // target left != null target center null\n                if (this.targetCenter == null) {\n\n                    // target left != null target center null target right null\n                    //   log(\" target left != null target center null target right null\");\n\n                    if (this.targetRight == null) {\n                        this.target = this.targetLeft;\n                        this.distance = this.distanceLeft;\n                        this.hitPoint = this.hitPointLeft;\n                    }\n                    // target left != null target center null target right != null\n\n                    else {\n                        //  log(\" target left != null target center null target right != null\");\n\n                        if (this.hitPointRight.x <= this.hitPointLeft.x) {\n                            this.target = this.targetRight;\n                            this.distance = this.distanceRight;\n                            this.hitPoint = this.hitPointRight;\n                        } else {\n                            this.target = this.targetLeft;\n                            this.distance = this.distanceLeft;\n                            this.hitPoint = this.hitPointLeft;\n                        }\n                    }\n                }\n                // target left != null target center !=null\n                else {\n                    if (this.targetRight == null) {\n                        // log(\"target left != null target center !=null target right null\");\n\n                        if (this.hitPointCenter.x <= this.hitPointLeft.x) {\n                            this.target = this.targetCenter;\n                            this.distance = this.distanceCenter;\n                            this.hitPoint = this.hitPointCenter;\n                        } else {\n                            this.target = this.targetLeft;\n                            this.distance = this.distanceLeft;\n                            this.hitPoint = this.hitPointLeft;\n                        }\n                    } else {\n                        //  log(\"target left != null target center !=null target right1= null\");\n\n                        if (this.hitPointCenter.x <= this.hitPointRight.x) {\n                            this.target = this.targetCenter;\n                            this.distance = this.distanceCenter;\n                            this.hitPoint = this.hitPointCenter;\n                        } else {\n                            this.target = this.targetRight;\n                            this.distance = this.distanceRight;\n                            this.hitPoint = this.hitPointRight;\n                        }\n\n                        if (this.hitPoint.x >= this.hitPointLeft.x) {\n                            this.target = this.targetLeft;\n                            this.distance = this.distanceLeft;\n                            this.hitPoint = this.hitPointLeft;\n                        }\n                    }\n                }\n            }\n\n        }\n    }\n\n    CalculateLine() {\n        this.GetTarget();\n\n        this.line.setWorldScale(0.48 * this.distance / 0.512, 0.02, 1);\n        if (this.target != null) {\n\n            const startPoint = this.hitPoint.x <= this.target.getWorldPosition().x ? this.hitPoint : this.target.getWorldPosition();\n            const endPoint = this.hitPoint.x >= this.target.getWorldPosition().x ? this.hitPoint : this.target.getWorldPosition();\n            const angleOut = this.calculateAngleBetweenPoints(startPoint, endPoint);\n            \n            //log(angleOut)\n            const offsetIn = startPoint.z >= endPoint.z ? 1 : 0;\n\n            const angleIn = angleOut + 90 + offsetIn * 180;\n            this.out.setRotationFromEuler(new Vec3(0, 0, angleOut));\n            this.in.setRotationFromEuler(new Vec3(0, 0, angleIn));\n\n            this.in.setScale(((Math.abs(angleOut)) / 90) * 2, 0.35, 1);\n            this.targetCenter = null;\n\n            this.in.active = false;\n            this.out.active = false;\n        } else {\n            this.in.active = false;\n            this.out.active = false;\n        }\n        this.circle.setPosition(0.503 * this.line.getWorldScale().x / 0.48, 0, 0);\n    }\n\n\n\n\n\n    calculateAngleBetweenPoints(pointA: Vec3, pointB: Vec3): number {\n        const deltaX = parseFloat(pointB.x.toFixed(4)) - parseFloat(pointA.x.toFixed(4));\n        const deltaZ = parseFloat(pointB.z.toFixed(4)) - parseFloat(pointA.z.toFixed(4));\n\n\n        //   log(deltaZ);\n        // Tính góc dựa trên vector này bằng hàm Math.atan2()\n        const angleRad = Math.atan2(-deltaZ, deltaX);\n\n        // Chuyển đổi góc từ radian sang độ\n        const angleDeg = misc.radiansToDegrees(angleRad);\n\n        return angleDeg;\n    }\n\n}\n\n\n"]}